### 五、事件
1.事件流
```text
1）概念：事件的流向，事件的执行顺序；
2）类型：
 i.事件冒泡：事件从里向外发生，事件从最精确对象(target)开始触发，然后到最不精确的对象(document)触发，（IE）；
 ii.事件捕获：事件从外向里发生，事件从最不精确的对象(document)开始触发，然后到最精确对象(target)触发，（网景）；
阻止浏览器默认行为
event.preventDefault()  //火狐
event.returnValue = false  //IE
阻止事件传播
event.stopPropagation()  //火狐
event.cancelBubble = true  //IE
```
2.事件模型
```text
1）DOM0：在事件类型前面加on，如：onclick；早期事件模型，所有浏览器适用；
2）DOM2：addEventListener(type,fn,useCapture) 事件监听器，IE8以下不支持；
参数：type----事件类型，例：click、mouseover...
fn----事件处理函数
useCapture----布尔值true或false
（true表示事件捕获，false表示事件冒泡）
解除事件：removeEventListener(type, fn, useCapture)
```
3.事件对象
```text
event事件对象只在事件发生的过程中才有效；
event对象中包含了所有与事件相关的信息（私有的、共有的属性和方法）；
```
4.事件委托
```text
1）概念：事件委托就是事件目标自身不处理事件，而是把处理事件委托给其父元素，甚至是document 来完成；
2）原理：利用事件传播的特征；
3）特点：
 i.提高性能和效率；
 ii.减少事件注册，节省内存占用；
 iii.未来元素无需再次注册事件；
```
5.事件的循环机制（Envent Loop）
```text
1）概念与原理：
当一个脚本执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入调用栈中，然后从头开始执行。

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起(其他模块进行处理)，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入到事件队列。

被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。
2）任务
 i.同步任务 => 调用栈 Call Stack；
 ii.异步任务 => 事件队列 Task Queue；
   异步任务又分为微任务和宏任务，当前调用栈执行完毕时会优先处理所有微任务队列中的事件，再处理宏任务队列中的事件
```